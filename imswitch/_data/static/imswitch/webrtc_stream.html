<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImSwitch WebRTC Streaming</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .parameter-group {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        .parameter-group h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #555;
            font-size: 14px;
            font-weight: bold;
        }
        .parameter-row {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }
        .parameter-row:last-child {
            margin-bottom: 0;
        }
        .parameter-row label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        button.primary {
            background-color: #4CAF50;
            color: white;
        }
        button.primary:hover {
            background-color: #45a049;
        }
        button.primary:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        button.danger {
            background-color: #f44336;
            color: white;
        }
        button.danger:hover {
            background-color: #da190b;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        input[type="range"] {
            padding: 0;
        }
        .range-value {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        #videoContainer {
            position: relative;
            background-color: #000;
            border-radius: 4px;
            overflow: hidden;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        video {
            max-width: 100%;
            max-height: 70vh;
            width: auto;
            height: auto;
            object-fit: contain; /* Preserve aspect ratio */
            display: block;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .stats {
            font-family: monospace;
            font-size: 12px;
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>ImSwitch WebRTC Live Streaming</h1>
    
    <div class="container">
        <h2>WebRTC Video Stream</h2>
        <div class="controls">
            <input type="text" id="serverUrl" placeholder="Server URL" value="http://localhost:8001">
            <input type="text" id="detectorName" placeholder="Detector Name (optional)">
            <button class="primary" id="startBtn" onclick="start()">Start WebRTC Stream</button>
            <button class="danger" id="stopBtn" onclick="stop()" disabled>Stop Stream</button>
        </div>
        
        <!-- Streaming Parameters -->
        <div class="parameter-grid">
            <div class="parameter-group">
                <h4>Quality Settings <span id="liveUpdateIndicator" style="font-size: 10px; color: #28a745; display: none;">‚óè LIVE</span></h4>
                <div class="parameter-row">
                    <label for="throttleMs">Frame Rate (ms between frames):</label>
                    <input type="range" id="throttleMs" min="16" max="200" value="50" oninput="updateRangeValue('throttleMs')">
                    <div class="range-value" id="throttleMsValue">50ms (~20 FPS)</div>
                </div>
                <div class="parameter-row">
                    <label for="subsamplingFactor">Subsampling Factor:</label>
                    <input type="range" id="subsamplingFactor" min="1" max="8" value="1" oninput="updateRangeValue('subsamplingFactor')">
                    <div class="range-value" id="subsamplingFactorValue">1x (Full resolution)</div>
                </div>
            </div>
            
            <div class="parameter-group">
                <h4>Network Settings</h4>
                <div class="parameter-row">
                    <label for="useStun">Use STUN servers (for internet streaming):</label>
                    <input type="checkbox" id="useStun" onchange="toggleStunServers()">
                </div>
                <div class="parameter-row" id="stunServerRow" style="display: none;">
                    <label for="stunServers">STUN Server URLs (one per line):</label>
                    <textarea id="stunServers" rows="3" placeholder="stun:stun.l.google.com:19302&#10;stun:stun1.l.google.com:19302">stun:stun.l.google.com:19302
stun:stun1.l.google.com:19302</textarea>
                </div>
                <div class="parameter-row">
                    <label>Connection Type:</label>
                    <div id="connectionType" style="font-size: 11px; color: #666;">Will be detected automatically</div>
                </div>
            </div>
            
            <div class="parameter-group">
                <h4>Advanced Settings</h4>
                <div class="parameter-row">
                    <label for="maxWidth">Max Width (pixels):</label>
                    <select id="maxWidth">
                        <option value="640">640px (SD)</option>
                        <option value="1280" selected>1280px (HD)</option>
                        <option value="1920">1920px (Full HD)</option>
                        <option value="0">Original size</option>
                    </select>
                </div>
                <div class="parameter-row">
                    <label for="compressionLevel">Compression Level:</label>
                    <input type="range" id="compressionLevel" min="0" max="9" value="0" oninput="updateRangeValue('compressionLevel')">
                    <div class="range-value" id="compressionLevelValue">0 (Fastest)</div>
                </div>
            </div>
        </div>
        
        <div id="status"></div>
        <div id="videoContainer">
            <video id="video" autoplay playsinline controls></video>
        </div>
        <div id="stats" class="stats hidden"></div>
    </div>

    <div class="container">
        <h2>How it works</h2>
        <p>This page uses WebRTC to stream live video from your ImSwitch detector with low latency.</p>
        <ul>
            <li><strong>Step 1:</strong> Configure streaming parameters above (frame rate, resolution, etc.)</li>
            <li><strong>Step 2:</strong> Click "Start WebRTC Stream" to connect to the server</li>
            <li><strong>Step 3:</strong> The browser will create a WebRTC offer and send it to the server</li>
            <li><strong>Step 4:</strong> The server will start streaming frames and send back an answer</li>
            <li><strong>Step 5:</strong> The WebRTC connection is established and video starts playing</li>
        </ul>
        
        <h3>Performance Tips</h3>
        <ul>
            <li><strong>Local/LAN:</strong> No STUN servers needed - fastest connection!</li>
            <li><strong>High frame rate:</strong> Reduce "Frame Rate" value (lower = faster)</li>
            <li><strong>Large images:</strong> Reduce "Max Width" or increase "Subsampling Factor"</li>
            <li><strong>Slow network:</strong> Enable subsampling and reduce resolution</li>
            <li><strong>Aspect ratio:</strong> Video maintains original camera proportions automatically</li>
        </ul>
        
        <h3>Troubleshooting</h3>
        <ul>
            <li><strong>Connection fails:</strong> Try enabling STUN servers for remote connections</li>
            <li><strong>Video too slow:</strong> Increase frame rate interval or reduce resolution</li>
            <li><strong>Video distorted:</strong> Check that your camera sensor aspect ratio matches the video display</li>
            <li><strong>No video:</strong> Check that ImSwitch detector is running and accessible</li>
        </ul>
        
        <p><strong>Requirements:</strong> Your browser must support WebRTC (all modern browsers do)</p>
        <p><strong>Local/LAN Usage:</strong> For localhost or LAN connections, no internet access is required! 
           The system automatically detects local connections and skips STUN server configuration for faster startup.</p>
    </div>

    <script>
        let pc = null;
        let video = document.getElementById('video');
        let statsInterval = null;

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }
        
        function updateRangeValue(id) {
            const slider = document.getElementById(id);
            const valueDiv = document.getElementById(id + 'Value');
            const value = parseInt(slider.value);
            
            switch(id) {
                case 'throttleMs':
                    const fps = Math.round(1000 / value);
                    valueDiv.textContent = `${value}ms (~${fps} FPS)`;
                    break;
                case 'subsamplingFactor':
                    if (value === 1) {
                        valueDiv.textContent = '1x (Full resolution)';
                    } else {
                        valueDiv.textContent = `${value}x (1/${value} resolution)`;
                    }
                    break;
                case 'compressionLevel':
                    const levels = ['Fastest', 'Fast', 'Medium', 'Medium', 'Medium', 'Medium', 'Slow', 'Slower', 'Slowest', 'Best'];
                    valueDiv.textContent = `${value} (${levels[value]})`;
                    break;
            }
            
            // Apply parameters dynamically if stream is active
            if (pc && pc.connectionState === 'connected') {
                applyParametersLive();
            }
        }
        
        async function applyParametersLive() {
            if (!pc || pc.connectionState !== 'connected') {
                return;
            }
            
            try {
                const serverUrl = document.getElementById('serverUrl').value;
                const streamParams = getStreamParameters();
                
                console.log('Applying parameters during streaming:', streamParams);
                showStatus('Updating streaming parameters...', 'info');
                
                // Send parameter update to backend
                const response = await fetch(`${serverUrl}/LiveViewController/setStreamParameters`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        protocol: 'webrtc',
                        params: streamParams
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'success') {
                        showStatus('Parameters updated successfully!', 'success');
                        console.log('Parameters updated:', result);
                        
                        // Update status after a short delay to show the change took effect
                        setTimeout(() => {
                            if (pc && pc.connectionState === 'connected') {
                                showStatus('Connected! Streaming video...', 'success');
                            }
                        }, 1000);
                    } else {
                        showStatus(`Failed to update parameters: ${result.message}`, 'error');
                    }
                } else {
                    showStatus('Failed to update parameters', 'error');
                }
                
            } catch (error) {
                console.error('Error updating parameters:', error);
                showStatus(`Error updating parameters: ${error.message}`, 'error');
            }
        }
        
        function toggleStunServers() {
            const useStun = document.getElementById('useStun').checked;
            const stunServerRow = document.getElementById('stunServerRow');
            stunServerRow.style.display = useStun ? 'block' : 'none';
        }
        
        function detectConnectionType() {
            const serverUrl = document.getElementById('serverUrl').value;
            const isLocal = serverUrl.includes('localhost') || 
                           serverUrl.includes('127.0.0.1') || 
                           serverUrl.includes('192.168.') ||
                           serverUrl.includes('10.0.') ||
                           serverUrl.includes('172.16.');
            
            const connectionType = document.getElementById('connectionType');
            if (isLocal) {
                connectionType.textContent = 'Local/LAN connection detected - STUN servers not needed';
                connectionType.style.color = '#28a745';
            } else {
                connectionType.textContent = 'Remote connection - STUN servers recommended';
                connectionType.style.color = '#ffc107';
            }
            return isLocal;
        }
        
        function getStreamParameters() {
            return {
                throttle_ms: parseInt(document.getElementById('throttleMs').value),
                subsampling_factor: parseInt(document.getElementById('subsamplingFactor').value),
                compression_level: parseInt(document.getElementById('compressionLevel').value),
                stun_servers: document.getElementById('useStun').checked ? 
                    document.getElementById('stunServers').value.split('\n').filter(s => s.trim()) : [],
                max_width: parseInt(document.getElementById('maxWidth').value) || 0
            };
        }
        
        // Initialize parameter displays
        window.addEventListener('load', function() {
            updateRangeValue('throttleMs');
            updateRangeValue('subsamplingFactor');
            updateRangeValue('compressionLevel');
            detectConnectionType();
            
            // Update connection type when server URL changes
            document.getElementById('serverUrl').addEventListener('input', detectConnectionType);
        });

        function updateStats() {
            if (!pc) return;
            
            pc.getStats(null).then(stats => {
                let statsText = '';
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        statsText += `Frames Received: ${report.framesReceived || 0}\n`;
                        statsText += `Frames Decoded: ${report.framesDecoded || 0}\n`;
                        statsText += `Frames Dropped: ${report.framesDropped || 0}\n`;
                        statsText += `Bytes Received: ${(report.bytesReceived || 0) / 1024 / 1024} MB\n`;
                        
                        if (report.framesPerSecond) {
                            statsText += `FPS: ${report.framesPerSecond.toFixed(1)}\n`;
                        }
                    }
                });
                
                if (statsText) {
                    document.getElementById('stats').textContent = statsText;
                    document.getElementById('stats').classList.remove('hidden');
                }
            });
        }

        async function negotiate() {
            const serverUrl = document.getElementById('serverUrl').value;
            const detectorName = document.getElementById('detectorName').value;
            const streamParams = getStreamParameters();
            const isLocal = detectConnectionType();
            
            // Detailed timing for profiling
            const timings = {
                start: performance.now(),
                offerCreated: 0,
                localDescSet: 0,
                iceComplete: 0,
                requestSent: 0,
                responseReceived: 0,
                remoteDescSet: 0
            };
            
            try {
                showStatus('Creating offer...', 'info');
                console.log('üöÄ Starting WebRTC negotiation at', new Date().toISOString());
                
                // Add a transceiver to receive video (this triggers ICE gathering)
                // Configure video codec preferences for better performance
                const transceiver = pc.addTransceiver('video', { 
                    direction: 'recvonly',
                    streams: []
                });
                
                // Prefer VP8 for lower latency on local connections
                const codecs = RTCRtpReceiver.getCapabilities('video').codecs;
                const preferredCodecs = [];
                
                // For local connections, prefer VP8 (lower latency)
                // For remote connections, prefer H.264 (better compression)
                if (isLocal) {
                    preferredCodecs.push(...codecs.filter(c => c.mimeType.includes('VP8')));
                    preferredCodecs.push(...codecs.filter(c => !c.mimeType.includes('VP8')));
                } else {
                    preferredCodecs.push(...codecs.filter(c => c.mimeType.includes('H264')));
                    preferredCodecs.push(...codecs.filter(c => !c.mimeType.includes('H264')));
                }
                
                if (preferredCodecs.length > 0) {
                    await transceiver.setCodecPreferences(preferredCodecs);
                }
                
                // Create offer with optimized settings
                const offerOptions = {
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false,
                    iceRestart: false
                };
                
                console.log('‚ö° Creating offer...');
                const offer = await pc.createOffer(offerOptions);
                timings.offerCreated = performance.now();
                console.log(`‚è±Ô∏è  Offer created in ${(timings.offerCreated - timings.start).toFixed(1)}ms`);
                
                await pc.setLocalDescription(offer);
                timings.localDescSet = performance.now();
                console.log(`‚è±Ô∏è  Local description set in ${(timings.localDescSet - timings.offerCreated).toFixed(1)}ms`);
                
                console.log('ICE gathering state after setLocalDescription:', pc.iceGatheringState);
                
                // Wait for ICE gathering to complete (with timeout)
                // Optimized timeout based on connection type
                const gatheringTimeout = isLocal ? 500 : 2000; // Faster for local connections
                
                console.log('üßä Waiting for ICE gathering...');
                await new Promise((resolve, reject) => {
                    let timeoutId = null;
                    
                    // Define the state change handler first
                    const checkState = () => {
                        console.log('ICE gathering state changed to:', pc.iceGatheringState);
                        if (pc.iceGatheringState === 'complete') {
                            if (timeoutId) clearTimeout(timeoutId);
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            timings.iceComplete = performance.now();
                            console.log(`‚è±Ô∏è  ICE gathering completed in ${(timings.iceComplete - timings.localDescSet).toFixed(1)}ms`);
                            resolve();
                        }
                    };
                    
                    // Check if already complete
                    if (pc.iceGatheringState === 'complete') {
                        timings.iceComplete = performance.now();
                        console.log(`‚è±Ô∏è  ICE gathering was already complete`);
                        resolve();
                    } else {
                        // Add event listener
                        pc.addEventListener('icegatheringstatechange', checkState);
                        
                        // Add timeout to prevent infinite waiting
                        timeoutId = setTimeout(() => {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            timings.iceComplete = performance.now();
                            console.log(`‚ö†Ô∏è  ICE gathering timeout after ${gatheringTimeout}ms, proceeding anyway. State: ${pc.iceGatheringState}`);
                            resolve(); // Proceed even if not complete
                        }, gatheringTimeout);
                    }
                });
                
                console.log('Final ICE gathering state:', pc.iceGatheringState);
                console.log('Offer SDP length:', pc.localDescription.sdp.length);
                console.log('Offer type:', pc.localDescription.type);
                console.log('Stream parameters:', streamParams);
                
                showStatus('Sending offer to server...', 'info');
                console.log('üì° Sending offer to server...');
                
                // Send offer to server with parameters
                const url = `${serverUrl}/LiveViewController/webrtc_offer`;
                const params = {
                    sdp: pc.localDescription.sdp,
                    sdp_type: pc.localDescription.type,
                    params: streamParams
                };
                
                if (detectorName) {
                    params.detectorName = detectorName;
                }
                
                console.log('Sending params:', {
                    detectorName: params.detectorName,
                    sdp_type: params.sdp_type,
                    sdp_length: params.sdp.length,
                    params: params.params
                });
                
                timings.requestSent = performance.now();
                console.log(`‚è±Ô∏è  Request prepared in ${(timings.requestSent - timings.iceComplete).toFixed(1)}ms`);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                
                timings.responseReceived = performance.now();
                console.log(`‚è±Ô∏è  Server response received in ${(timings.responseReceived - timings.requestSent).toFixed(1)}ms`);
                console.log('Response status:', response.status);
                const answer = await response.json();
                console.log('Answer received:', {
                    status: answer.status,
                    type: answer.type,
                    has_sdp: !!answer.sdp
                });
                
                if (answer.status === 'error') {
                    throw new Error(answer.message || 'Server error');
                }
                
                showStatus('Received answer from server, establishing connection...', 'info');
                console.log('üîÑ Setting remote description...');
                
                // Set remote description
                await pc.setRemoteDescription(new RTCSessionDescription({
                    sdp: answer.sdp,
                    type: answer.type
                }));
                
                timings.remoteDescSet = performance.now();
                console.log(`‚è±Ô∏è  Remote description set in ${(timings.remoteDescSet - timings.responseReceived).toFixed(1)}ms`);
                
                showStatus('WebRTC connection established!', 'success');
                console.log('‚úÖ WebRTC negotiation completed!');
                
                // Print complete timing breakdown
                const totalTime = timings.remoteDescSet - timings.start;
                console.log('üïê Complete timing breakdown:');
                console.log(`   Total time: ${totalTime.toFixed(1)}ms`);
                console.log(`   Offer creation: ${(timings.offerCreated - timings.start).toFixed(1)}ms`);
                console.log(`   Local desc set: ${(timings.localDescSet - timings.offerCreated).toFixed(1)}ms`);
                console.log(`   ICE gathering: ${(timings.iceComplete - timings.localDescSet).toFixed(1)}ms`);
                console.log(`   Request prep: ${(timings.requestSent - timings.iceComplete).toFixed(1)}ms`);
                console.log(`   Server response: ${(timings.responseReceived - timings.requestSent).toFixed(1)}ms`);
                console.log(`   Remote desc set: ${(timings.remoteDescSet - timings.responseReceived).toFixed(1)}ms`);
                
                // Start stats monitoring
                statsInterval = setInterval(updateStats, 1000);
                
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error('Negotiation error:', error);
                stop();
            }
        }

        async function start() {
            try {
                showStatus('Starting WebRTC connection...', 'info');
                
                // Disable start button
                document.getElementById('startBtn').disabled = true;
                
                // Create peer connection
                // For local connections (localhost/LAN), we don't need STUN servers
                // Configure ICE servers based on connection type and user settings
                const serverUrl = document.getElementById('serverUrl').value;
                const isLocalConnection = serverUrl.includes('localhost') || 
                                         serverUrl.includes('127.0.0.1') || 
                                         serverUrl.includes('192.168.') ||
                                         serverUrl.includes('10.0.') ||
                                         serverUrl.includes('172.16.');
                
                let config = {};
                
                if (!isLocalConnection && document.getElementById('useStun').checked) {
                    // Use user-configured STUN servers for remote connections
                    const stunServers = document.getElementById('stunServers').value
                        .split('\n')
                        .filter(s => s.trim())
                        .map(url => ({ urls: url.trim() }));
                    
                    if (stunServers.length > 0) {
                        config.iceServers = stunServers;
                    }
                } else if (!isLocalConnection) {
                    // Default STUN servers for remote connections
                    config.iceServers = [{urls: 'stun:stun.l.google.com:19302'}];
                }
                // For local connections, use empty config (no ICE servers needed)
                
                // Add performance optimizations
                config.iceCandidatePoolSize = isLocalConnection ? 0 : 4; // Optimize for connection type
                config.bundlePolicy = 'max-bundle'; // Better performance
                config.rtcpMuxPolicy = 'require'; // Reduce port usage
                
                console.log('Using config:', config, 'isLocal:', isLocalConnection);
                
                pc = new RTCPeerConnection(config);
                
                // Handle incoming tracks
                pc.addEventListener('track', (evt) => {
                    console.log('Track received:', evt.track.kind);
                    if (evt.track.kind === 'video') {
                        video.srcObject = evt.streams[0];
                        showStatus('Video track received, starting playback...', 'success');
                    }
                });
                
                // Handle connection state with more detailed feedback
                pc.addEventListener('connectionstatechange', () => {
                    console.log('Connection state:', pc.connectionState);
                    const liveIndicator = document.getElementById('liveUpdateIndicator');
                    
                    if (pc.connectionState === 'connected') {
                        showStatus('Connected! Streaming video...', 'success');
                        document.getElementById('stopBtn').disabled = false;
                        liveIndicator.style.display = 'inline'; // Show live indicator
                    } else if (pc.connectionState === 'connecting') {
                        showStatus('Connecting...', 'info');
                        liveIndicator.style.display = 'none';
                    } else if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                        showStatus('Connection failed or closed', 'error');
                        liveIndicator.style.display = 'none';
                        stop();
                    }
                });
                
                // Handle ICE connection state with feedback
                pc.addEventListener('iceconnectionstatechange', () => {
                    console.log('ICE connection state:', pc.iceConnectionState);
                    if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                        showStatus('ICE connection established', 'success');
                    } else if (pc.iceConnectionState === 'failed') {
                        showStatus('ICE connection failed - check network settings', 'error');
                    }
                });
                
                // Start negotiation
                await negotiate();
                
            } catch (error) {
                showStatus(`Error starting stream: ${error.message}`, 'error');
                console.error('Start error:', error);
                document.getElementById('startBtn').disabled = false;
            }
        }

        function stop() {
            showStatus('Stopping stream...', 'info');
            
            // Hide live indicator
            document.getElementById('liveUpdateIndicator').style.display = 'none';
            
            // Stop stats monitoring
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            
            // Close peer connection
            if (pc) {
                pc.close();
                pc = null;
            }
            
            // Stop video
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // Hide stats
            document.getElementById('stats').classList.add('hidden');
            
            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showStatus('Stream stopped', 'info');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stop);
    </script>
</body>
</html>
